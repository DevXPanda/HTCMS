import { WaterTaxAssessment, WaterConnection, Property, Demand, DemandItem } from '../models/index.js';
import { Op } from 'sequelize';

/**
 * Water tax demand generation logic (assessments + amounts per connection).
 * Used by unified orchestrator.
 */

const generateWaterAssessmentNumber = async (assessmentYear) => {
  const timestamp = Date.now().toString();
  const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
  return `WTA-${assessmentYear}-${timestamp.slice(-8)}-${random}`;
};

/**
 * Calculate water tax base amount based on assessment type.
 */
export const calculateWaterTaxAmount = (assessmentType, rate, monthlyRate = null) => {
  if (assessmentType === 'FIXED') {
    return parseFloat(rate || 0) * 12;
  }
  const estimatedAnnualConsumption = 1000;
  return parseFloat(rate || 0) * estimatedAnnualConsumption;
};

/**
 * Get or create water tax assessment for one connection.
 * @returns {{ assessment: WaterTaxAssessment, created: boolean }}
 */
export const getOrCreateWaterAssessment = async (waterConnectionId, propertyId, assessmentYear, assessorId, transaction = null) => {
  const existingAssessment = await WaterTaxAssessment.findOne({
    where: {
      waterConnectionId,
      assessmentYear,
      status: { [Op.in]: ['draft', 'pending', 'approved'] }
    },
    transaction
  });

  if (existingAssessment) {
    return { assessment: existingAssessment, created: false };
  }

  const waterConnection = await WaterConnection.findByPk(waterConnectionId, { transaction });
  if (!waterConnection) {
    throw new Error('Water connection not found');
  }
  const property = await Property.findByPk(propertyId, { transaction });
  if (!property) {
    throw new Error('Property not found');
  }
  if (property.isActive === false) {
    throw new Error(`Cannot generate water tax assessment for inactive property ${property.propertyNumber || propertyId}. Property must be active to receive assessments.`);
  }

  let assessmentType = 'FIXED';
  let rate = 0;
  if (waterConnection.isMetered) {
    assessmentType = 'METERED';
    rate = 5.0;
  } else {
    assessmentType = 'FIXED';
    rate = parseFloat(waterConnection.monthlyRate || 100);
  }

  const assessmentNumber = await generateWaterAssessmentNumber(assessmentYear);
  const assessment = await WaterTaxAssessment.create({
    assessmentNumber,
    propertyId,
    waterConnectionId,
    assessmentYear,
    assessmentType,
    rate,
    assessorId,
    status: 'draft',
    remarks: 'Auto-generated by unified tax service'
  }, { transaction });

  return { assessment, created: true };
};

/**
 * Compute water arrears for a specific connection (from previous demands with WATER items for this connection).
 */
export const computeWaterArrearsPerConnection = async (waterConnectionId, financialYear, transaction = null) => {
  const previousDemands = await Demand.findAll({
    where: {
      financialYear: { [Op.ne]: financialYear },
      status: { [Op.in]: ['pending', 'overdue', 'partially_paid'] }
    },
    include: [
      {
        model: DemandItem,
        as: 'items',
        where: {
          taxType: 'WATER',
          connectionId: waterConnectionId
        }
      }
    ],
    transaction
  });

  let connectionArrears = 0;
  for (const demand of previousDemands) {
    const waterItems = demand.items || [];
    for (const item of waterItems) {
      if (item.connectionId === waterConnectionId) {
        const itemTotal = parseFloat(item.totalAmount || 0);
        const itemPaid = parseFloat(item.paidAmount || 0);
        connectionArrears += itemTotal - itemPaid;
      }
    }
  }
  return Math.round(connectionArrears * 100) / 100;
};

/**
 * Get or create water assessments for all active connections and compute base + arrears per connection.
 * Used by unified orchestrator (no Demand created here).
 * @returns {{ waterAssessments: Array<{ assessment: WaterTaxAssessment, baseAmount: number, arrearsAmount: number, created: boolean }> }}
 */
export const getOrCreateAssessmentsAndComputeAmounts = async (propertyId, assessmentYear, financialYear, assessorId, transaction = null) => {
  const waterConnections = await WaterConnection.findAll({
    where: { propertyId, status: 'ACTIVE' },
    transaction
  });

  const waterAssessments = [];
  for (const connection of waterConnections) {
    const { assessment, created } = await getOrCreateWaterAssessment(
      connection.id,
      propertyId,
      assessmentYear,
      assessorId,
      transaction
    );
    const baseAmount = calculateWaterTaxAmount(assessment.assessmentType, assessment.rate, null);
    const arrearsAmount = await computeWaterArrearsPerConnection(assessment.waterConnectionId, financialYear, transaction);
    waterAssessments.push({ assessment, baseAmount, arrearsAmount, created });
  }
  return { waterAssessments };
};
