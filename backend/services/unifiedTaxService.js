import { Assessment, WaterTaxAssessment, Demand, DemandItem, Property, WaterConnection, User, Ward } from '../models/index.js';
import { Op } from 'sequelize';
import { sequelize } from '../config/database.js';
import {
  getActivePenaltyRule,
  calculateOverdueDays,
  shouldApplyPenalty,
  calculatePenalty,
  calculateInterest
} from './penaltyCalculator.js';

/**
 * Unified Tax Assessment and Demand Generation Service
 * 
 * This service generates:
 * 1. Property Tax Assessment (if not exists)
 * 2. Water Tax Assessment for all active water connections (if not exists)
 * 3. ONE unified tax demand containing both property and water tax items
 */

/**
 * Generate assessment number for property tax
 */
const generateUniquePropertyAssessmentNumber = async (assessmentYear) => {
  const timestamp = Date.now().toString(); // Use full timestamp
  const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
  return `ASS-${assessmentYear}-${timestamp.slice(-8)}-${random}`;
};

/**
 * Generate assessment number for water tax
 */
const generateWaterAssessmentNumber = async (assessmentYear) => {
  const timestamp = Date.now().toString(); // Use full timestamp
  const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
  return `WTA-${assessmentYear}-${timestamp.slice(-8)}-${random}`;
};

/**
 * Calculate water tax base amount based on assessment type
 */
const calculateWaterTaxAmount = (assessmentType, rate, monthlyRate = null) => {
  if (assessmentType === 'FIXED') {
    // For FIXED: rate is the fixed monthly amount, multiply by 12 for annual
    return parseFloat(rate || 0) * 12;
  } else {
    // For METERED: rate is per unit, use estimated annual consumption
    // Default: 1000 units/year (can be made configurable)
    const estimatedAnnualConsumption = 1000;
    return parseFloat(rate || 0) * estimatedAnnualConsumption;
  }
};

/**
 * Generate or get existing Property Tax Assessment
 */
const generatePropertyTaxAssessment = async (propertyId, assessmentYear, assessorId, defaultTaxRate = 1.5, transaction = null) => {
  // Check if assessment already exists
  const existingAssessment = await Assessment.findOne({
    where: {
      propertyId,
      assessmentYear,
      status: { [Op.in]: ['draft', 'pending', 'approved'] }
    },
    transaction
  });

  if (existingAssessment) {
    return { assessment: existingAssessment, created: false };
  }

  // Get property to calculate assessed value
  const property = await Property.findByPk(propertyId, { transaction });
  if (!property) {
    throw new Error('Property not found');
  }

  // Prevent assessment generation for inactive properties
  if (property.isActive === false) {
    throw new Error(`Cannot generate property tax assessment for inactive property ${property.propertyNumber || propertyId}. Property must be active to receive assessments.`);
  }

  // Calculate assessed value (simplified - can be enhanced)
  // For now, use a default calculation based on property area
  const assessedValue = parseFloat(property.area || 0) * 1000; // ₹1000 per sq ft (default)
  const taxRate = defaultTaxRate; // 1.5% default
  const netAssessedValue = assessedValue;
  const annualTaxAmount = (netAssessedValue * taxRate) / 100;

  // Generate assessment number
  const assessmentNumber = await generateUniquePropertyAssessmentNumber(assessmentYear);
  console.log('DEBUG: propertyId:', propertyId, 'Generated Assessment Number:', assessmentNumber);

  // Create assessment
  const assessment = await Assessment.create({
    assessmentNumber,
    propertyId,
    assessmentYear,
    assessedValue,
    taxRate,
    annualTaxAmount,
    assessorId,
    status: 'draft',
    remarks: 'Auto-generated by unified tax service'
  }, { transaction });

  return { assessment, created: true };
};

/**
 * Generate or get existing Water Tax Assessment for a connection
 */
const generateWaterTaxAssessment = async (waterConnectionId, propertyId, assessmentYear, assessorId, transaction = null) => {
  // Check if assessment already exists
  const existingAssessment = await WaterTaxAssessment.findOne({
    where: {
      waterConnectionId,
      assessmentYear,
      status: { [Op.in]: ['draft', 'pending', 'approved'] }
    },
    transaction
  });

  if (existingAssessment) {
    return { assessment: existingAssessment, created: false };
  }

  // Get water connection
  const waterConnection = await WaterConnection.findByPk(waterConnectionId, { transaction });
  if (!waterConnection) {
    throw new Error('Water connection not found');
  }

  // Validate that the property is active
  const property = await Property.findByPk(propertyId, { transaction });
  if (!property) {
    throw new Error('Property not found');
  }

  // Prevent assessment generation for inactive properties
  if (property.isActive === false) {
    throw new Error(`Cannot generate water tax assessment for inactive property ${property.propertyNumber || propertyId}. Property must be active to receive assessments.`);
  }

  // Determine assessment type and rate
  let assessmentType = 'FIXED';
  let rate = 0;

  if (waterConnection.isMetered) {
    assessmentType = 'METERED';
    // Default rate: ₹5 per unit for metered
    rate = 5.0;
  } else {
    assessmentType = 'FIXED';
    // Use monthly rate from connection, or default ₹100/month
    rate = parseFloat(waterConnection.monthlyRate || 100);
  }

  // Generate assessment number
  const assessmentNumber = await generateWaterAssessmentNumber(assessmentYear);

  // Create assessment
  const assessment = await WaterTaxAssessment.create({
    assessmentNumber,
    propertyId,
    waterConnectionId,
    assessmentYear,
    assessmentType,
    rate,
    assessorId,
    status: 'draft',
    remarks: 'Auto-generated by unified tax service'
  }, { transaction });

  return { assessment, created: true };
};

/**
 * Calculate arrears for a property
 */
const calculateArrears = async (propertyId, financialYear, serviceType) => {
  const previousDemands = await Demand.findAll({
    where: {
      propertyId,
      serviceType,
      financialYear: { [Op.ne]: financialYear },
      status: { [Op.in]: ['pending', 'overdue', 'partially_paid'] }
    }
  });

  return Math.round(previousDemands.reduce((sum, prevDemand) => {
    return sum + parseFloat(prevDemand.balanceAmount || 0);
  }, 0) * 100) / 100;
};

/**
 * Calculate water arrears for a specific connection
 * This looks at previous water tax demands for this specific connection
 */
const calculateWaterArrearsPerConnection = async (waterConnectionId, financialYear) => {
  // Find previous demands that contain water items for this specific connection
  const previousDemands = await Demand.findAll({
    where: {
      financialYear: { [Op.ne]: financialYear },
      status: { [Op.in]: ['pending', 'overdue', 'partially_paid'] }
    },
    include: [
      {
        model: DemandItem,
        as: 'items',
        where: {
          taxType: 'WATER',
          connectionId: waterConnectionId
        }
      }
    ]
  });

  // Calculate arrears from the demand items for this connection
  let connectionArrears = 0;
  for (const demand of previousDemands) {
    const waterItems = demand.items || [];
    for (const item of waterItems) {
      if (item.connectionId === waterConnectionId) {
        // Calculate the arrears for this specific item using item-level paidAmount
        const itemTotal = parseFloat(item.totalAmount || 0);
        const itemPaid = parseFloat(item.paidAmount || 0);
        const itemBalance = itemTotal - itemPaid;
        connectionArrears += itemBalance;
      }
    }
  }

  return Math.round(connectionArrears * 100) / 100;
};

/**
 * Generate unified tax demand
 * 
 * @param {number} propertyId - Property ID
 * @param {number} assessmentYear - Assessment year
 * @param {string} financialYear - Financial year (e.g., "2024-25")
 * @param {number} assessorId - User ID of assessor
 * @param {Date} dueDate - Due date for the demand
 * @param {string} remarks - Optional remarks
 * @returns {Promise<Object>} Unified demand with both property and water tax items
 */
export const generateUnifiedTaxAssessmentAndDemand = async ({
  propertyId,
  assessmentYear,
  financialYear,
  assessorId,
  dueDate = null,
  remarks = null,
  defaultTaxRate = 1.5
}) => {
  const transaction = await sequelize.transaction();

  try {
    // Validate property exists and is active
    const property = await Property.findByPk(propertyId, { transaction });
    if (!property) {
      throw new Error('Property not found');
    }

    // Prevent assessment generation for inactive properties
    if (property.isActive === false) {
      throw new Error(`Cannot generate assessment for inactive property ${property.propertyNumber || propertyId}. Property must be active to receive assessments.`);
    }

    // Validate financial year format
    if (!financialYear || !/^\d{4}-\d{2}$/.test(financialYear)) {
      throw new Error('Invalid financial year format. Expected format: YYYY-YY (e.g., 2024-25)');
    }

    const results = {
      propertyId,
      assessmentYear,
      financialYear,
      propertyAssessment: null,
      waterAssessments: [],
      unifiedDemand: null,
      demandItems: [],
      created: {
        propertyAssessment: false,
        waterAssessments: [],
        demand: false
      },
      errors: []
    };

    // Step 1: Generate or get Property Tax Assessment
    try {
      console.log('DEBUG: Generating Property Assessment...');
      const { assessment, created } = await generatePropertyTaxAssessment(
        propertyId,
        assessmentYear,
        assessorId,
        defaultTaxRate,
        transaction
      );
      console.log('DEBUG: Generated Property Assessment:', assessment.assessmentNumber, 'Created:', created);
      results.propertyAssessment = assessment;
      results.created.propertyAssessment = created;
    } catch (error) {
      console.error('DEBUG: Property Assessment Error:', error);
      results.errors.push({
        type: 'PROPERTY_ASSESSMENT',
        message: error.message
      });
    }

    // Step 2: Get all active water connections for the property
    const waterConnections = await WaterConnection.findAll({
      where: {
        propertyId,
        status: 'ACTIVE'
      },
      transaction
    });

    // Step 3: Generate or get Water Tax Assessments for each active connection
    for (const connection of waterConnections) {
      try {
        console.log('DEBUG: Generating Water Assessment for connection', connection.id);
        const { assessment, created } = await generateWaterTaxAssessment(
          connection.id,
          propertyId,
          assessmentYear,
          assessorId,
          transaction
        );
        console.log('DEBUG: Generated Water Assessment:', assessment.assessmentNumber, 'Created:', created);
        results.waterAssessments.push(assessment);
        results.created.waterAssessments.push({ connectionId: connection.id, created });
      } catch (error) {
        console.error('DEBUG: Water Assessment Error:', error);
        results.errors.push({
          type: 'WATER_ASSESSMENT',
          connectionId: connection.id,
          message: error.message
        });
      }
    }

    // Step 4: Check if unified demand already exists (idempotency)
    const existingDemand = await Demand.findOne({
      where: {
        propertyId,
        financialYear,
        serviceType: 'HOUSE_TAX', // Use HOUSE_TAX as base, but store both assessments
        remarks: {
          [Op.like]: `%UNIFIED_DEMAND%`
        }
      },
      transaction
    });

    if (existingDemand) {
      await transaction.rollback();
      return {
        ...results,
        unifiedDemand: existingDemand,
        message: 'Unified demand already exists for this property and financial year'
      };
    }

    // Step 5: Calculate amounts
    let propertyTaxBaseAmount = 0;
    let propertyTaxArrears = 0;
    if (results.propertyAssessment) {
      propertyTaxBaseAmount = parseFloat(results.propertyAssessment.annualTaxAmount || 0);
      propertyTaxArrears = await calculateArrears(propertyId, financialYear, 'HOUSE_TAX');
    }

    let waterTaxBaseAmount = 0;
    let waterTaxArrears = 0;
    for (const waterAssessment of results.waterAssessments) {
      const amount = calculateWaterTaxAmount(
        waterAssessment.assessmentType,
        waterAssessment.rate,
        null
      );
      waterTaxBaseAmount += amount;
    }

    // Calculate water arrears by summing individual connection arrears
    for (const waterAssessment of results.waterAssessments) {
      const connectionArrears = await calculateWaterArrearsPerConnection(
        waterAssessment.waterConnectionId,
        financialYear
      );
      waterTaxArrears += connectionArrears;
    }

    // Step 6: Validate that we have at least one assessment
    if (!results.propertyAssessment && results.waterAssessments.length === 0) {
      await transaction.rollback();
      throw new Error('No assessments could be generated. Property may not have active water connections or assessment data is missing.');
    }

    // Compute totals before penalty calc (used as penalty base)
    const totalBaseAmount = propertyTaxBaseAmount + waterTaxBaseAmount;
    const totalArrears = propertyTaxArrears + waterTaxArrears;

    // Step 7: Calculate penalty/interest (Option A: stored at Demand level only)
    // If dueDate is already in the past at creation, apply penalty immediately.
    // Otherwise keep 0 and let cron apply when it becomes overdue.
    const effectiveDueDate = dueDate ? new Date(dueDate) : new Date();
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    let penaltyAmount = 0;
    let interestAmount = 0;
    let overdueDays = 0;
    let lastPenaltyAppliedAt = null;
    let penaltyBreakdown = null;

    if (effectiveDueDate < today) {
      const rule = await getActivePenaltyRule(financialYear);
      if (rule) {
        // Build a provisional demand object for calculation (not saved yet)
        const provisionalTotal = Math.round((totalBaseAmount + totalArrears) * 100) / 100;
        const provisionalDemand = {
          baseAmount: totalBaseAmount,
          arrearsAmount: totalArrears,
          paidAmount: 0,
          balanceAmount: provisionalTotal,
          penaltyAmount: 0,
          interestAmount: 0,
          status: 'pending',
          dueDate: effectiveDueDate,
          lastPenaltyAppliedAt: null
        };

        overdueDays = calculateOverdueDays(effectiveDueDate, rule.gracePeriodDays);
        if (shouldApplyPenalty(provisionalDemand, rule, overdueDays)) {
          penaltyAmount = calculatePenalty(provisionalDemand, rule, overdueDays);
          interestAmount = calculateInterest(provisionalDemand, rule, overdueDays);
          lastPenaltyAppliedAt = new Date();
          penaltyBreakdown = [
            {
              date: lastPenaltyAppliedAt.toISOString(),
              overdueDays,
              penalty: penaltyAmount,
              interest: interestAmount,
              totalPenalty: penaltyAmount,
              totalInterest: interestAmount,
              reason: `Applied at creation (due date already passed). Rule: ${rule.ruleName}`
            }
          ];
        }
      }
    }

    // Step 8: Create unified demand with proper serviceType
    // Determine serviceType based on what assessments exist
    let demandServiceType = 'HOUSE_TAX';
    if (!results.propertyAssessment && results.waterAssessments.length > 0) {
      // Only water tax exists
      demandServiceType = 'WATER_TAX';
    } else if (results.propertyAssessment && results.waterAssessments.length > 0) {
      // Both exist - use HOUSE_TAX as base (unified)
      demandServiceType = 'HOUSE_TAX';
    }

    const totalAmount = Math.round((totalBaseAmount + totalArrears + penaltyAmount + interestAmount) * 100) / 100;

    // Generate demand number
    const demandNumber = `UD-${financialYear}-${Date.now()}-${propertyId}`;

    // Store assessment IDs in remarks as JSON for reference
    // IMPORTANT: Set remarks BEFORE creating demand so validation hook can detect unified demand
    const demandRemarks = JSON.stringify({
      type: 'UNIFIED_DEMAND',
      propertyAssessmentId: results.propertyAssessment?.id || null,
      waterAssessmentIds: results.waterAssessments.map(a => a.id),
      breakdown: {
        propertyTax: {
          baseAmount: propertyTaxBaseAmount,
          arrears: propertyTaxArrears,
          hasAssessment: !!results.propertyAssessment
        },
        waterTax: {
          baseAmount: waterTaxBaseAmount,
          arrears: waterTaxArrears,
          connectionCount: results.waterAssessments.length,
          connections: results.waterAssessments.map(a => ({
            assessmentId: a.id,
            connectionId: a.waterConnectionId,
            amount: calculateWaterTaxAmount(a.assessmentType, a.rate)
          }))
        },
        total: {
          baseAmount: totalBaseAmount,
          arrears: totalArrears,
          penalty: penaltyAmount,
          interest: interestAmount,
          total: totalAmount
        }
      },
      customRemarks: remarks
    });

    // Create unified demand
    // For unified demands: if only water tax exists, use WATER_TAX serviceType
    // If property tax exists (with or without water), use HOUSE_TAX serviceType
    // The validation hook will check remarks to allow unified demands
    const unifiedDemand = await Demand.create({
      demandNumber,
      propertyId,
      assessmentId: results.propertyAssessment?.id || null, // Only set if property assessment exists
      waterTaxAssessmentId: results.waterAssessments[0]?.id || null,
      serviceType: demandServiceType,
      financialYear,
      baseAmount: totalBaseAmount,
      arrearsAmount: totalArrears,
      penaltyAmount,
      interestAmount,
      totalAmount,
      balanceAmount: totalAmount,
      paidAmount: 0,
      dueDate: effectiveDueDate,
      status: (overdueDays > 0 ? 'overdue' : 'pending'),
      generatedBy: assessorId,
      remarks: demandRemarks, // Set remarks so validation hook can detect unified demand
      // If penalty applied at creation, persist bookkeeping to avoid duplicate application
      overdueDays: overdueDays > 0 ? overdueDays : 0,
      lastPenaltyAppliedAt,
      penaltyBreakdown
    }, { transaction });

    // Step 9: Create demand items for detailed breakdown
    const demandItems = [];

    // Create Property Tax demand item
    if (results.propertyAssessment && propertyTaxBaseAmount > 0) {
      const propertyItemTotal = Math.round((propertyTaxBaseAmount + propertyTaxArrears) * 100) / 100;
      const propertyItem = await DemandItem.create({
        demandId: unifiedDemand.id,
        taxType: 'PROPERTY',
        referenceId: results.propertyAssessment.id,
        connectionId: null,
        baseAmount: propertyTaxBaseAmount,
        arrearsAmount: propertyTaxArrears,
        penaltyAmount: 0,
        interestAmount: 0,
        totalAmount: propertyItemTotal,
        description: `Property Tax - Assessment ${results.propertyAssessment.assessmentNumber}`,
        metadata: {
          assessmentId: results.propertyAssessment.id,
          assessmentNumber: results.propertyAssessment.assessmentNumber,
          assessedValue: results.propertyAssessment.assessedValue,
          taxRate: results.propertyAssessment.taxRate
        }
      }, { transaction });
      demandItems.push(propertyItem);
    }

    // Pre-fetch all water connections to avoid N+1 queries
    const waterConnectionIds = results.waterAssessments.map(assessment => assessment.waterConnectionId);
    const connectionDetails = await WaterConnection.findAll({
      where: {
        id: { [Op.in]: waterConnectionIds }
      },
      transaction
    });

    // Create in-memory map for O(1) lookup
    const connectionMap = new Map();
    connectionDetails.forEach(connection => {
      connectionMap.set(connection.id, connection);
    });

    // Create Water Tax demand items (one per connection)
    for (const waterAssessment of results.waterAssessments) {
      const waterItemBaseAmount = calculateWaterTaxAmount(
        waterAssessment.assessmentType,
        waterAssessment.rate
      );
      // Calculate arrears per connection based on previous unpaid demands for this specific connection
      const waterItemArrears = await calculateWaterArrearsPerConnection(
        waterAssessment.waterConnectionId,
        financialYear
      );
      const waterItemTotal = Math.round((waterItemBaseAmount + waterItemArrears) * 100) / 100;

      // Get connection details from in-memory map (O(1) lookup)
      const connection = connectionMap.get(waterAssessment.waterConnectionId);

      const waterItem = await DemandItem.create({
        demandId: unifiedDemand.id,
        taxType: 'WATER',
        referenceId: waterAssessment.id,
        connectionId: waterAssessment.waterConnectionId,
        baseAmount: waterItemBaseAmount,
        arrearsAmount: waterItemArrears,
        penaltyAmount: 0,
        interestAmount: 0,
        totalAmount: waterItemTotal,
        description: `Water Tax - Connection ${connection?.connectionNumber || waterAssessment.waterConnectionId} (${waterAssessment.assessmentType})`,
        metadata: {
          assessmentId: waterAssessment.id,
          assessmentNumber: waterAssessment.assessmentNumber,
          connectionId: waterAssessment.waterConnectionId,
          connectionNumber: connection?.connectionNumber || null,
          connectionType: connection?.connectionType || null,
          isMetered: connection?.isMetered || false,
          assessmentType: waterAssessment.assessmentType,
          rate: waterAssessment.rate
        }
      }, { transaction });
      demandItems.push(waterItem);
    }

    results.unifiedDemand = unifiedDemand;
    results.demandItems = demandItems;
    results.created.demand = true;

    await transaction.commit();

    // Fetch full demand details with associations
    const demandWithDetails = await Demand.findByPk(unifiedDemand.id, {
      include: [
        {
          model: Property,
          as: 'property',
          include: [
            { model: User, as: 'owner', attributes: ['id', 'firstName', 'lastName', 'email'] },
            { model: Ward, as: 'ward', attributes: ['id', 'wardNumber', 'wardName'] }
          ]
        },
        { model: Assessment, as: 'assessment', required: false },
        { model: WaterTaxAssessment, as: 'waterTaxAssessment', required: false },
        {
          model: DemandItem,
          as: 'items',
          include: [
            { model: WaterConnection, as: 'waterConnection', required: false }
          ]
        }
      ]
    });

    results.unifiedDemand = demandWithDetails;

    return results;
  } catch (error) {
    await transaction.rollback();
    throw error;
  }
};

/**
 * Get unified demand breakdown
 */
export const getUnifiedDemandBreakdown = async (demandId) => {
  const demand = await Demand.findByPk(demandId, {
    include: [
      {
        model: Property,
        as: 'property',
        include: [
          { model: User, as: 'owner', attributes: ['id', 'firstName', 'lastName', 'email', 'phone'] },
          { model: Ward, as: 'ward', attributes: ['id', 'wardNumber', 'wardName'] },
          {
            model: WaterConnection,
            as: 'waterConnections',
            where: { status: 'ACTIVE' },
            required: false
          }
        ]
      },
      { model: Assessment, as: 'assessment', required: false },
      { model: WaterTaxAssessment, as: 'waterTaxAssessment', required: false },
      {
        model: DemandItem,
        as: 'items',
        include: [
          { model: WaterConnection, as: 'waterConnection', required: false }
        ],
        order: [['taxType', 'ASC'], ['id', 'ASC']]
      }
    ]
  });

  if (!demand) {
    throw new Error('Demand not found');
  }

  // Determine unified demand (and avoid using stored remarks breakdown, which can get stale)
  const remarksString = typeof demand.remarks === 'string' ? demand.remarks : '';
  const isUnified =
    (remarksString && remarksString.includes('UNIFIED_DEMAND')) ||
    (Array.isArray(demand.items) && demand.items.length > 0);

  // Always compute a LIVE breakdown from demand items + demand-level penalty/interest.
  // Option A: penalty/interest are stored ONLY at Demand level (not distributed to items).
  let breakdown = null;
  if (isUnified) {
    const items = Array.isArray(demand.items) ? demand.items : [];
    const propertyItems = items.filter((item) => item.taxType === 'PROPERTY');
    const waterItems = items.filter((item) => item.taxType === 'WATER');

    const propertyBase = propertyItems.reduce((sum, item) => sum + parseFloat(item.baseAmount || 0), 0);
    const propertyArrears = propertyItems.reduce((sum, item) => sum + parseFloat(item.arrearsAmount || 0), 0);
    const waterBase = waterItems.reduce((sum, item) => sum + parseFloat(item.baseAmount || 0), 0);
    const waterArrears = waterItems.reduce((sum, item) => sum + parseFloat(item.arrearsAmount || 0), 0);

    const itemsBaseTotal = Math.round((propertyBase + waterBase) * 100) / 100;
    const itemsArrearsTotal = Math.round((propertyArrears + waterArrears) * 100) / 100;
    const itemsSubtotal = Math.round((itemsBaseTotal + itemsArrearsTotal) * 100) / 100;

    const demandBaseTotal = parseFloat(demand.baseAmount || 0);
    const demandArrearsTotal = parseFloat(demand.arrearsAmount || 0);
    const demandPenalty = parseFloat(demand.penaltyAmount || 0);
    const demandInterest = parseFloat(demand.interestAmount || 0);
    const demandTotal = parseFloat(demand.totalAmount || 0);

    breakdown = {
      penaltyModel: 'DEMAND_LEVEL',
      note: 'Penalty/interest are applied on the total demand (demand-level), not per item.',
      propertyTax: {
        baseAmount: Math.round(propertyBase * 100) / 100,
        arrearsAmount: Math.round(propertyArrears * 100) / 100,
        subtotalAmount: Math.round((propertyBase + propertyArrears) * 100) / 100,
        hasAssessment: propertyItems.length > 0
      },
      waterTax: {
        baseAmount: Math.round(waterBase * 100) / 100,
        arrearsAmount: Math.round(waterArrears * 100) / 100,
        subtotalAmount: Math.round((waterBase + waterArrears) * 100) / 100,
        connectionCount: waterItems.length,
        connections: waterItems.map((item) => ({
          assessmentId: item.referenceId,
          connectionId: item.connectionId,
          connectionNumber: item.metadata?.connectionNumber || null,
          amount: parseFloat(item.baseAmount || 0)
        }))
      },
      totals: {
        // Demand-level (source of truth)
        baseAmount: Math.round(demandBaseTotal * 100) / 100,
        arrearsAmount: Math.round(demandArrearsTotal * 100) / 100,
        penaltyAmount: Math.round(demandPenalty * 100) / 100,
        interestAmount: Math.round(demandInterest * 100) / 100,
        totalAmount: Math.round(demandTotal * 100) / 100,

        // Item subtotals (for UI reconciliation)
        itemsBaseAmount: itemsBaseTotal,
        itemsArrearsAmount: itemsArrearsTotal,
        itemsSubtotalAmount: itemsSubtotal,
        expectedTotalAmount: Math.round((itemsSubtotal + demandPenalty + demandInterest) * 100) / 100,
        differenceAmount: Math.round((demandTotal - (itemsSubtotal + demandPenalty + demandInterest)) * 100) / 100
      }
    };
  }

  return {
    demand,
    isUnified,
    breakdown,
    items: demand.items || []
  };
};

/**
 * Get unified tax summary for a property
 * @param {number} propertyId - Property ID
 * @param {number} assessmentYear - Assessment year (optional)
 * @returns {Promise<Object>} Unified summary with assessments and demand
 */
export const getUnifiedTaxSummary = async (propertyId, assessmentYear = null) => {
  const property = await Property.findByPk(propertyId, {
    include: [
      { model: User, as: 'owner', attributes: ['id', 'firstName', 'lastName', 'email', 'phone'] },
      { model: Ward, as: 'ward', attributes: ['id', 'wardNumber', 'wardName'] },
      {
        model: WaterConnection,
        as: 'waterConnections',
        where: { status: 'ACTIVE' },
        required: false
      }
    ]
  });

  if (!property) {
    throw new Error('Property not found');
  }

  // Get property tax assessment
  const propertyAssessmentWhere = { propertyId };
  if (assessmentYear) {
    propertyAssessmentWhere.assessmentYear = assessmentYear;
  }
  const propertyAssessment = await Assessment.findOne({
    where: propertyAssessmentWhere,
    order: [['assessmentYear', 'DESC'], ['createdAt', 'DESC']],
    include: [
      { model: User, as: 'assessor', attributes: ['id', 'firstName', 'lastName'] },
      { model: User, as: 'approver', attributes: ['id', 'firstName', 'lastName'] }
    ]
  });

  // Get water tax assessments
  const waterAssessmentWhere = { propertyId };
  if (assessmentYear) {
    waterAssessmentWhere.assessmentYear = assessmentYear;
  }
  const waterAssessments = await WaterTaxAssessment.findAll({
    where: waterAssessmentWhere,
    include: [
      { model: WaterConnection, as: 'waterConnection' },
      { model: User, as: 'assessor', attributes: ['id', 'firstName', 'lastName'] },
      { model: User, as: 'approver', attributes: ['id', 'firstName', 'lastName'] }
    ],
    order: [['assessmentYear', 'DESC'], ['createdAt', 'DESC']]
  });

  // Get unified demand (if exists)
  const unifiedDemand = await Demand.findOne({
    where: {
      propertyId,
      remarks: {
        [Op.like]: `%UNIFIED_DEMAND%`
      }
    },
    include: [
      {
        model: DemandItem,
        as: 'items',
        include: [
          { model: WaterConnection, as: 'waterConnection', required: false }
        ]
      }
    ],
    order: [['createdAt', 'DESC']]
  });

  return {
    property,
    propertyAssessment,
    waterAssessments,
    unifiedDemand,
    summary: {
      hasPropertyTax: !!propertyAssessment,
      hasWaterTax: waterAssessments.length > 0,
      waterConnectionCount: property.waterConnections?.length || 0,
      hasUnifiedDemand: !!unifiedDemand
    }
  };
};

// Export the new function for testing and external use
export { calculateWaterArrearsPerConnection };
