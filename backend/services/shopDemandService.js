import { Shop, ShopTaxAssessment, Demand, Property } from '../models/index.js';
import { Op } from 'sequelize';

/**
 * Shop tax demand generation logic.
 * Used by unified orchestrator to generate separate shop demands for shops at a property.
 */

/**
 * Generate shop demands for all active shops at a property with approved assessments.
 * Each shop creates its own separate Demand record (not DemandItem).
 * @returns {Array<{ demand: Demand, shopTaxAssessment: ShopTaxAssessment, shop: Shop, created: boolean }>}
 */
export const generateShopDemandsForProperty = async (propertyId, financialYear, assessorId, dueDate = null, transaction = null) => {
  const shops = await Shop.findAll({
    where: {
      propertyId,
      status: 'active'
    },
    include: [
      {
        model: ShopTaxAssessment,
        as: 'shopTaxAssessments',
        where: {
          status: 'approved'
        },
        required: true
      }
    ],
    transaction
  });

  const shopDemands = [];

  for (const shop of shops) {
    // Get the most recent approved assessment for this shop
    const approvedAssessments = shop.shopTaxAssessments || [];
    if (approvedAssessments.length === 0) continue;

    // Use the most recent approved assessment
    const shopTaxAssessment = approvedAssessments.sort((a, b) => {
      const yearA = a.assessmentYear || 0;
      const yearB = b.assessmentYear || 0;
      return yearB - yearA;
    })[0];

    // Check if demand already exists (idempotency)
    const existingDemand = await Demand.findOne({
      where: {
        shopTaxAssessmentId: shopTaxAssessment.id,
        financialYear,
        serviceType: 'SHOP_TAX'
      },
      transaction
    });

    if (existingDemand) {
      shopDemands.push({
        demand: existingDemand,
        shopTaxAssessment,
        shop,
        created: false
      });
      continue;
    }

    // Create shop demand
    const dueDateResolved = dueDate ? new Date(dueDate) : new Date(`${financialYear.split('-')[1]}-03-31`);
    const baseAmount = parseFloat(shopTaxAssessment.annualTaxAmount || 0);
    const arrearsAmount = 0; // Shop demands don't carry arrears in this implementation
    const penaltyAmount = 0;
    const interestAmount = 0;
    const totalAmount = Math.round((baseAmount + arrearsAmount + penaltyAmount + interestAmount) * 100) / 100;
    const demandNumber = `STD-${financialYear}-${Date.now()}-${shop.id}`;

    let demand;
    try {
      demand = await Demand.create({
        demandNumber,
        propertyId: shop.propertyId,
        assessmentId: null,
        waterTaxAssessmentId: null,
        shopTaxAssessmentId: shopTaxAssessment.id,
        serviceType: 'SHOP_TAX',
        financialYear,
        baseAmount,
        arrearsAmount,
        penaltyAmount,
        interestAmount,
        totalAmount,
        balanceAmount: totalAmount,
        paidAmount: 0,
        dueDate: dueDateResolved,
        status: 'pending',
        generatedBy: assessorId,
        remarks: `Auto-generated by unified orchestrator for shop ${shop.shopNumber}`
      }, { transaction });
    } catch (createError) {
      // Unique constraint violation: return existing demand idempotently
      const isUniqueViolation =
        createError.name === 'SequelizeUniqueConstraintError' ||
        (createError.parent && createError.parent.code === '23505');
      if (isUniqueViolation) {
        const existing = await Demand.findOne({
          where: { shopTaxAssessmentId: shopTaxAssessment.id, financialYear, serviceType: 'SHOP_TAX' },
          transaction
        });
        if (existing) {
          shopDemands.push({
            demand: existing,
            shopTaxAssessment,
            shop,
            created: false
          });
          continue;
        }
      }
      throw createError;
    }

    shopDemands.push({
      demand,
      shopTaxAssessment,
      shop,
      created: true
    });
  }

  return shopDemands;
};
